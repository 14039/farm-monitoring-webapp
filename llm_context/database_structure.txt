The database supports a few different types of sensors in a standardized format.

create table sensor (
hardware_id (an integer value assigned for each new device)

name (a string that is the human-readable name of the device)

sensor_type (a string, there will be temperature, soil humidity, electrical conductivity, camera, etc. sensors)

gps_latitude (gps latitude value)

gps_longitude (gps longitude value)

metadata (a JSON that I can populate with whatever else I decide needs to be stored here)


);

create table reading (
sensor_id (the hardware_id of the sensor the reading came from; this will link the sensor table to the reading table)

timestamp (a timestamp of when the measurement was taken)

sequence (an integer value from the sensor, which will increment each time a new reading is sent)

temperature_c (double precision)

humidity_pct (double precision)

capacitance_val (double precision)

battery_v (double precision)

rssi_dbm (smallint)

primary key (sensor_id, timestamp)

)

create table image_asset (
  id            uuid primary key default gen_random_uuid(),
  reading_id    uuid not null references reading(id) on delete cascade,
  -- denormalize for convenience: fast “images last week for sensor X”
  sensor_id     bigint not null references sensor(hardware_id) on delete cascade,
  ts            timestamptz not null,
  -- S3 pointer + metadata
  s3_bucket     text not null,
  s3_key        text not null,
  content_type  text not null default 'image/jpeg',
  bytes         bigint not null,
  width         integer,
  height        integer,
  etag          text,                  -- S3 ETag
  sha256        bytea,                 -- real checksum you compute
  exif          jsonb not null default '{}'::jsonb,
  unique (s3_bucket, s3_key)
);

